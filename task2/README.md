1. Использование внутренних инструментов для автоматического обновления витрины PostgreSQL ограничено использованием сторонних расширений,
таких как [pg_ivm](https://pganalyze.com/blog/5mins-postgres-15-beta1-incremental-materialized-views-pg-ivm), и триггеров.
Теоретическое решение (я бы не имплементировал его, а воспользовался бы внешними инструментами, т.к. данное решение требует излишних ограничений)
с использованием триггеров представлено в файле: `agg_operations_trigers.sql`.
Данное решение будет работать в случае, когда обновление таблиц `deposits` и `withdrawals` происходит нечасто (скажем, раз в час)
и операций, обновляющих таблицу за раз, немного, иначе есть риск, что что-то может пойти не так, например, возникнет слишком много concurrent вызовов триггера, много deadlocks и это положит сервер.
Второе ограничение это обновление данных таблиц `deposits` и `withdrawals` внутри `READ COMMITTED` транзакции, чтобы при операциях
`UPDATE,DELETE` внутри триггеров был выделен lock на соответствующие строки.
2. Использование внутренних инструментов для автоматического обновления витрины ClickHouse возможно, например, с помощью
`MATERIALIZED VIEW`. Решение представлено в файле: `agg_operations_materialized_view.sql`. Поскольку ClickHouse есть OLAP база данных,
она не предназначена для потоковой записи в таблицы `deposits`, `withdrawals`, а это именно наш кейс, как я полагаю. Поэтому данное
решение тоже не имеет большого практического смысла, но, если запись в таблицы `deposits`, `withdrawals` ведется батчами и
нечасто (например, раз в час, из OLTP базы данных), то это отличный вариант.
3. Автоматическое обновление витрин данных может быть реализовано внешними инструментами, такими как:
   - cron job + bash/python/{other_language} script
   - Airflow + bash/{other_language} script or python code
   - Airflow + dbt
   - dbt Cloud
   - etc.

    Здесь можно как обновлять таблицу целиком (используя в качестве bash скрипта скрипт, выполняющий
`REFRESH MATERIALIZED VIEW`, если таблица `date_agg_operations` является `MATERIALIZED VIEW` и СУБД поддерживает
такой метод обновления витрины, как, например, PostgreSQL, или просто через пару `TRUNCATE,INSERT SELECT` для обычных таблиц),
или партицированно (`PARTITION BY toDate(created_at)`), если есть понимание, за какие промежутки времени таблицы `deposits`, `withdrawals` могут быть обновлены.
Я бы использовал связку Airflow/cron job + python code, в котором обновлял бы только нужные партиции, предварительно изучив,
на какой горизонт в прошлом может происходить обновление данных. Партицирование позволило бы сэкономить вычислительные и временные ресурсы.
Если данные могут обновляться всюду или невозможно достоверно установить, что данные обновляются только за последние N дней,
то обновлял бы таблицу целиком с помощью Airflow/cron job + bash/python script.


